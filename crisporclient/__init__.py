"""
Crispor Client.

This module calls out to crispor.tefor.net endpoints. Crispor does not have
an official public web API. You've been warned!
"""
import requests

from abc import abstractmethod
from bs4 import BeautifulSoup
from collections import OrderedDict
from typing import Any, Dict, Tuple
from urllib.parse import quote


class AbstractCrisporRequest:

    def __repr__(self):
        return '{}({}, {})'.format(self.__class__, self.endpoint, self.__dict__.get('data'))

    def __str__(self):
        return self.__repr__()

    @abstractmethod
    def run(self) -> Dict[str, Any]:
        """Requests self.endpoint and extracts relevant data from the HTML response"""


class CrisporGuideRequest(AbstractCrisporRequest):
    """
    Given a sequence or chromosome location, gets candidate Crispr guides from
    Crispor service.

    >>> data = CrisporGuideRequest(name='test-crispr-guides', seq='chr1:11,130,540-11,130,751').run()
    >>> len(data['primer_urls']) > 3
    True
    """

    def __init__(self, seq: str, name: str = '', org: str = 'hg19', pam: str = 'NGG') -> None:
        self.data = {
            'name': name,
            'seq': seq,
            'org': org,
            'pam': pam,
            'submit': 'SUBMIT',
        }
        self.endpoint = 'http://crispor.tefor.net/crispor.py'

    def run(self) -> Dict[str, Any]:
        response = requests.post(self.endpoint, data=self.data)
        soup = BeautifulSoup(response.text, 'html.parser')
        return self._extract_data(soup)

    # TODO (gdingle): need to also handle case of queued request
    def _extract_data(self, soup: BeautifulSoup) -> Dict[str, Any]:
        title = soup.find(class_='title')
        if title and 'not present in the selected genome' in title.get_text():
            raise ValueError('Crispor: ' + title.get_text())

        output_table = soup.find('table', {'id': 'otTable'})
        if not output_table:
            raise Exception('No Crispor output rows in: {}'.format(soup.find('body')))
        rows = output_table.find_all(class_='guideRow')

        batch_id = soup.find('input', {'name': 'batchId'})['value']
        url = self.endpoint + '?batchId=' + batch_id
        primers_url = self.endpoint + '?batchId={}&pamId={}&pam=NGG'

        return dict(
            url=url,
            batch_id=batch_id,
            title=soup.title.string,
            variant_database=soup.find('select', {'name': 'varDb'})
            .find('option', {'selected': 'selected'})
            .get_text(),
            min_freq=float(soup.find('input', {'name': 'minFreq'})['value']),
            guide_seqs=OrderedDict((t['id'], t.find_next('tt').get_text()) for t in rows),
            primer_urls=OrderedDict((t['id'], primers_url.format(batch_id, quote(t['id']))) for t in rows),
            fasta_url=self.endpoint + '?batchId={}&download=fasta'.format(batch_id),
            benchling_url=self.endpoint + '?batchId={}&download=benchling'.format(batch_id),
            # TODO (gdingle): other formats?
            guides_url=self.endpoint + '?batchId={}&download=guides&format=tsv'.format(batch_id),
            offtargets_url=self.endpoint + '?batchId={}&download=offtargets&format=tsv'.format(batch_id),
        )


class CrisporGuideRequestById(CrisporGuideRequest):
    """
    Given an existing Crispor batch, gets candidate guides.

    >>> batch_id = '9cJNEsbfWiSKa8wlaJMZ'
    >>> data = CrisporGuideRequestById(batch_id).run()
    >>> data['batch_id'] == batch_id
    True

    >>> batch_id = '5JS3eHUiAeaV6eTSZ9av'
    >>> data = CrisporGuideRequestById(batch_id).run()
    Traceback (most recent call last):
    ...
    ValueError: Crispor: Query sequence, not present in the selected genome, Homo sapiens (hg19)
    """

    def __init__(self, batch_id) -> None:
        self.endpoint = 'http://crispor.tefor.net/crispor.py?batchId=' + batch_id

    def run(self) -> Dict[str, Any]:
        response = requests.get(self.endpoint)
        soup = BeautifulSoup(response.text, 'html.parser')
        return self._extract_data(soup)


class CrisporPrimerRequest(AbstractCrisporRequest):
    """
    Gets candidate primers for a guide generated by Crispor.

    >>> data = CrisporPrimerRequest('9cJNEsbfWiSKa8wlaJMZ', 's185+').run()
    >>> len(data['primer_tables']) > 3
    True
    """

    def __init__(self, batch_id: str, pam_id: str, amp_len: int = 400, tm: int = 60, pam: str = 'NGG') -> None:
        pam_id = quote(pam_id)  # percent encode the '+' symbol
        self.endpoint = 'http://crispor.tefor.net/crispor.py' + \
            '?ampLen={amp_len}&tm={tm}&batchId={batch_id}&pamId={pam_id}&pam={pam}'.format(**locals())

    def __repr__(self):
        return 'CrisporPrimerRequest({})'.format(self.endpoint)

    def run(self) -> Dict[str, Any]:
        response = requests.get(self.endpoint)
        soup = BeautifulSoup(response.text, 'html.parser')
        return self._extract_data(soup)

    def _extract_data(self, soup: BeautifulSoup) -> Dict[str, Any]:
        primer_tables, primer_seqs = self._extract_tables(soup)
        return dict(
            url=self.endpoint,
            amplicon_length=soup
            .find('select', {'name': 'ampLen'})
            .find('option', {'selected': 'selected'})['value'],
            primer_temp=soup
            .find('select', {'name': 'tm'})
            .find('option', {'selected': 'selected'})['value'],
            primer_tables=primer_tables,
            primer_seqs=primer_seqs,
        )

    def _extract_tables(self, soup: BeautifulSoup) -> Tuple[OrderedDict, OrderedDict]:
        table_dict = OrderedDict([])  # type: OrderedDict[str, dict]
        seq_dict = OrderedDict([])  # type: OrderedDict[str, str]
        tables = soup.find_all(class_='primerTable')
        for table in tables:
            table_name = table.find_previous('h3').get_text()
            rows = table.find_all('tr')
            table_data = {}
            for row in rows:
                cells = row.find_all('td')
                if len(cells):  # not all primerTable have data
                    primer_id = cells[0].get_text()
                    primer_id = primer_id.replace('(constant primer used for all guide RNAs)', '').strip()
                    primer_seq = cells[1].get_text()
                    table_data[primer_id] = primer_seq
                    seq_dict[primer_id] = primer_seq
            table_dict[table_name] = table_data
        return table_dict, seq_dict


if __name__ == '__main__':
    import doctest
    doctest.testmod()
